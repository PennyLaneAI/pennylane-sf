The GBS device
==============

This device gives access to a near-term model of photonic quantum computing called `Gaussian
boson sampling <https://strawberryfields.ai/photonics/concepts/gbs.html>`__ (GBS). It is run on
Strawberry Field's
`Gaussian simulator backend <https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.backends.GaussianBackend.html>`_.
The GBS model can encode graphs using their adjacency matrix :math:`A`, with a number of known
`applications <https://strawberryfields.ai/photonics/applications.html>`__. The encoding also
fixes a mean number of photons generated by the device. Its output is a
collection of samples listing the number of photons counted in each mode, resulting in a
probability distribution that captures information about the encoded graph.

The GBS device can then be trained by varying the initial adjacency matrix according to some
trainable parameters. When doing this, we can access the output GBS probability distribution as
well as its derivative.



.. note::

    It is also possible to perform GBS using other devices in Pennylane-SF. However, gradient
    evaluation is calculated using the finite-difference rule. The purpose of this device is to
    provide a setting where the gradient can be evaluated analytically using a fixed method of
    varying an encoded adjacency matrix.

Usage
~~~~~

You can instantiate the GBS device in PennyLane as follows:

.. code-block:: python

    import pennylane as qml

    dev = qml.device('strawberryfields.gbs', wires=4, cutoff_dim=4)

Note that a ``cutoff_dim`` argument is used to truncate the number of photons in the output GBS
probability distribution.

The GBS device represents a fixed circuit where we can:

- Vary an input adjacency matrix according to some trainable parameters and embed the result into
  GBS,
- Measure the output probability distribution.

Hence, QNodes bound to the ``strawberryfields.gbs`` device must consist solely of the
:class:`~.ParamGraphEmbed` operation, and must return Fock probabilities. For example:

.. code-block:: python

    from pennylane_sf.ops import ParamGraphEmbed
    import numpy as np

    A = np.array([
        [0.0, 1.0, 1.0, 1.0],
        [1.0, 0.0, 1.0, 0.0],
        [1.0, 1.0, 0.0, 0.0],
        [1.0, 0.0, 0.0, 0.0]])
    n_mean = 2.5

    @qml.qnode(dev)
    def quantum_function(x):
        ParamGraphEmbed(x, A, n_mean, wires=range(4))
        return qml.probs(wires=range(4))

Here,

* ``A`` is a symmetric `adjacency matrix <https://en.wikipedia.org/wiki/Adjacency_matrix>`__ of a
  graph, with the size of the adjacency matrix matching the number of wires on the device;

* ``n_mean`` is the initial mean number of photons for the output samples;

* ``x`` are a set of real, non-negative trainable parameters; and

* :class:`~.ParamGraphEmbed` embeds a parametrized graph :math:`WAW` onto the GBS
  device, where :math:`W` is a diagonal matrix dependent on parameters ``x`` (see below for
  further details).

The initial values of the trainable parameters ``x`` must be non-negative and are typically chosen
with an initial value close to one (which results in an unchanged ``A``):

>>> x = 0.9 * np.ones(4)

The GBS probability distribution can then be evaluated using:

>>> quantum_function(x)

The derivative of the probability distribution can also be calculated using standard methods in
PennyLane. For example,

>>> d_quantum_function = qml.jacobian(quantum_function)
>>> d_quantum_function(x)

The GBS probability distribution can also be post-processed and used as the input to other QNodes
or classical nodes.

Background
~~~~~~~~~~

The GBS device can be trained by varying the adjacency matrix :math:`A` of a graph according to
some trainable parameters :math:`\mathbf{w}`. One way to include trainable parameters is to
transform :math:`A` according to

.. math::

    A \rightarrow WAW,

where :math:`W` is a diagonal matrix with values given by :math:`\sqrt{\mathbf{w}}`. Using this
approach, a `recent paper <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012417>`__
has shown how to calculate the derivative of the output GBS probability distribution
:math:`P(\mathbf{n}, \mathbf{w})`:

.. math::

    \partial_{\mathbf{w}} P(\mathbf{n}, \mathbf{w}) = \frac{\mathbf{n} - \langle\mathbf{n}\rangle}{\mathbf{w}}P(\mathbf{n}, \mathbf{w}),,

where :math:`\mathbf{n}` is a sample given by counting the number of photons observed in each mode.

Caching
~~~~~~~

The probability :math:`P(\mathbf{n}, \mathbf{w})` of a sample :math:`\mathbf{n}` according to
trainable parameters :math:`\mathbf{w}` can be calculated as:

.. math::

    P(\mathbf{n}, \mathbf{w}) = \frac{Z(A)}{Z(WAW)} \prod_{i=1}^{n} w_{i}^{n_{i}},

where :math:`Z` is a normalization coefficient.
This means that the probability distribution and its derivative can be calculated directly from
the probability distribution of :math:`A`. This observation is particularly useful for devices in
non-analytic mode, allowing us to generate a reference set of samples from :math:`A` and rescale
the resulting probability distribution to give :math:`P(\mathbf{n}, \mathbf{w})` for any choice of
:math:`\mathbf{w}`.

This behaviour can be realized in the GBS device by setting the ``use_cache=True`` argument (in
non-analytic mode):

>>> dev = qml.device('strawberryfields.gbs', wires=4, cutoff_dim=4,
...                  shots=10, use_cache=True, analytic=False)

When the probability distribution using this device and the above ``quantum_function()`` is first
evaluated, samples will instead be generated from :math:`A` and cached (stored). Subsequent
evaluations of the probability distribution will then make use of this internal cache rather than
generating new samples, resulting in a faster evaluation.

It is also possible to input a NumPy array of pre-generated samples from :math:`A` when
instantiating the GBS device using the ``samples`` argument:

>>> dev = qml.device('strawberryfields.gbs', wires=4, cutoff_dim=4,
...                  samples=my_array, use_cache=True, analytic=False)

This allows the initial generation of samples during the first evaluation of the probability
distribution to be skipped.

Device options
~~~~~~~~~~~~~~

The GBS device accepts additional arguments beyond the PennyLane default device arguments.

``cutoff_dim``
    the Fock basis truncation to be applied when computing probabilities in the Fock basis.

``shots=1000``
	The number of circuit evaluations/random samples used to estimate probabilities.
	Only used when ``analytic=False``, otherwise probabilities are exact.

``use_cache``
    Indicates whether to use samples from previous evaluations to speed up the calculation of the
    probability distribution. Only used when ``analytic=False``.

``samples``
    Allows pre-generated samples of the input adjacency matrix to be provided in non-analytic mode.
    When ``use_cache=True``, these samples will be used to infer the probability distribution for
    any choice of trainable parameter.

Supported operations
~~~~~~~~~~~~~~~~~~~~

The GBS device supports is a restricted model of quantum computing and supports only the
following operations and return types:

**Supported operations:**

.. raw:: html

    <div class="summary-table">

.. autosummary::
    :nosignatures:

    ~pennylane_sf.ops.ParamGraphEmbed

.. raw:: html

    </div>

**Supported return types:**

.. raw:: html

    <div class="summary-table">

.. autosummary::
    :nosignatures:

    ~pennylane.probs

.. raw:: html

    </div>
